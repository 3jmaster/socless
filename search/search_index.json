{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SOCless SOCless is a serverless framework built to help security teams easily automate their incident response and operations processes. Overview SOCless uses the AWS Step Functions and AWS Lambda services to execute user-defined workflows. The workflows, called Playbooks, are defined as JSON objects and triggered by real-time alerts from http-based data sources or scheduled events from AWS CloudWatch . (Click to enlarge) Features Respond to real-time or scheduled events Orchestrate existing security tools into workflows using AWS Lambda functions written in Python 3 Interact with humans as part of automated workflows and adapt to their responses Connect to internal resources via static IP whitelisting Develop use-cases rapidly courtesy of reusable, modular and shareable plugins Store and deploy infrastructure and response plans as code using The Serverless Framework Enjoy low cost, low operational overhead, and effortless scalability courtesy of serverless design Extend architecture to implement unique use-cases using AWS services To get started, deploy SOCless! Join our community Slack workspace","title":"Home"},{"location":"#socless","text":"SOCless is a serverless framework built to help security teams easily automate their incident response and operations processes.","title":"SOCless"},{"location":"#overview","text":"SOCless uses the AWS Step Functions and AWS Lambda services to execute user-defined workflows. The workflows, called Playbooks, are defined as JSON objects and triggered by real-time alerts from http-based data sources or scheduled events from AWS CloudWatch . (Click to enlarge)","title":"Overview"},{"location":"#features","text":"Respond to real-time or scheduled events Orchestrate existing security tools into workflows using AWS Lambda functions written in Python 3 Interact with humans as part of automated workflows and adapt to their responses Connect to internal resources via static IP whitelisting Develop use-cases rapidly courtesy of reusable, modular and shareable plugins Store and deploy infrastructure and response plans as code using The Serverless Framework Enjoy low cost, low operational overhead, and effortless scalability courtesy of serverless design Extend architecture to implement unique use-cases using AWS services To get started, deploy SOCless! Join our community Slack workspace","title":"Features"},{"location":"about/","text":"About SOCless Join our community Slack workspace","title":"About SOCless"},{"location":"about/#about-socless","text":"Join our community Slack workspace","title":"About SOCless"},{"location":"betterment-template/","text":"Situation Background Assessment Recommendation Definition of Done Status: UNCLAIMED Lead: N/A","title":"Betterment Template"},{"location":"betterment-template/#situation","text":"","title":"Situation"},{"location":"betterment-template/#background","text":"","title":"Background"},{"location":"betterment-template/#assessment","text":"","title":"Assessment"},{"location":"betterment-template/#recommendation","text":"","title":"Recommendation"},{"location":"betterment-template/#definition-of-done","text":"","title":"Definition of Done"},{"location":"betterment-template/#status-unclaimed","text":"Lead: N/A","title":"Status: UNCLAIMED"},{"location":"betterments-list/","text":"Introduction The SOCless Betterments List is a list of improvements the Socless automation framework needs to become the premier security automation framework. How to use the list Each item on this list is an opportunity to own a significant component of Socless and guide it to success. Read through each item of the list and take ownership of a betterment you're excited to tackle. As you work on a betterment, ensure that is is always updated with one and only one of the below statuses: UNCLAIMED: The betterment is not actively owned by an individual SPIKING: An individual/team has claimed ownership of the project and is actively working on solution proposal IN PROGRESS: A proposed solution has been accepted and is being implemented DEPLOYED: The solution has been deployed to the Socless production environment ABANDONED: The betterment has been abandoned and will no longer be applied to the platform Important note: Owning a betterment does not mean you have to work on it alone. It is highly recommended that you collaborate with a team throughout the lifecycle of the process. However, there can be only one owner for a betterment. That owner is designated as the lead.","title":"Betterment List Overview"},{"location":"betterments-list/#introduction","text":"The SOCless Betterments List is a list of improvements the Socless automation framework needs to become the premier security automation framework.","title":"Introduction"},{"location":"betterments-list/#how-to-use-the-list","text":"Each item on this list is an opportunity to own a significant component of Socless and guide it to success. Read through each item of the list and take ownership of a betterment you're excited to tackle. As you work on a betterment, ensure that is is always updated with one and only one of the below statuses: UNCLAIMED: The betterment is not actively owned by an individual SPIKING: An individual/team has claimed ownership of the project and is actively working on solution proposal IN PROGRESS: A proposed solution has been accepted and is being implemented DEPLOYED: The solution has been deployed to the Socless production environment ABANDONED: The betterment has been abandoned and will no longer be applied to the platform Important note: Owning a betterment does not mean you have to work on it alone. It is highly recommended that you collaborate with a team throughout the lifecycle of the process. However, there can be only one owner for a betterment. That owner is designated as the lead.","title":"How to use the list"},{"location":"collect-information-using-a-slack-dialog/","text":"For the final part of our tutorial, let's learn to trigger a Slack Dialog . Slack Dialogs allow humans to provide detailed information to a playbook. The Socless Slack integration for sending dialogs is called SendDialog. Like PromptForConfirmation, it relies on Socless' human interaction workflow as well, which, as we learned, means it needs to be followed by an AwaitMessageResponseActivity state. In addition, Slack Dialogs have lifecycle requirements that we'll learn about in this tutorial. The lifecycle for working with a Slack Dialog on any platform is: Slack User responds to an interactive message (e.g. button press) or uses a slash command. This generates a trigger_id that is valid for 3 seconds Backend system uses trigger_id to open a Slack Dialog for the user. A Slack Dialog can't be opened without the trigger_id that is generated when a user interacts with an interactive message or slash command User either submits or cancels the dialog. This sends either a dialog_submission or dialog_cancellation event back to the backend system. Backend system handles either dialog_submission or dialog_cancellation event When Slack Dialogs are implemented in Socless, the \"Backend system\" described above is the Socless Playbook. Thus, to use a Slack Dialog in Socless, you need to: Send an Interactive Message using PromptForConfirmaton, or request a slash command be run using PromptForResponse Socless Slack Integrations Pass the trigger_id that is included in the user's response by Slack to the Socless Slack SendDialog integration, to open the dialog Wait for the Users' Dialog Response Use a Choice State to check if the user submitted or canceled the dialog Handle each response as appropriate. Let's learn how to implement this by modifying our InvestigateLogin playbook to request additional information -- via a dialog -- when a user specifies that they did NOT perform the login we prompted them to confirm. Start by reconfiguring the Did_User_Login Choice state to transition Request_More_Info instead of Reassure_User when a user responds \"no\" to our prompt for login verification. Don't delete the Reassure_User state, however. We'll still need to reassure the user that help is one the way after we collect more information. Next, Configure Request_More_Info to use our SendDialog integration to request more information as shown below. You can add the configuration anywhere in the States object. Order of states in the States object doesn't matter. All that matters is that transitions are configured correctly. \"Request_More_Info\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.slack.SendDialog}}\", \"Parameters\": { \"receiver\": \"Await_Additional_Info\", \"trigger_id\": \"$.results.Await_User_Verification.trigger_id\", \"title\": \"Tell Us More\", \"elements\": [ { \"label\": \"Where and when was your last login to your account?\", \"name\": \"additional_info\", \"optional\": false, \"placeholder\": \"My last log in was at ... from ....\", \"type\": \"text\" } ] }, \"Next\": \"Await_Additional_Info\" }, \"Await_Additional_Info\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.socless.AwaitMessageResponseActivity}}\", \"Next\": \"Did_User_Submit_Dialog\" } SendDialog is configured to follow the Human Interaction Workflow. Pay attention to the parameters passed, specifically trigger_id and elements. trigger_id is sourced from Await_User_Verification -- the state that receives our user's response to the button press. elements is built according to Slack's documentation on authoring Dialog elements . Be sure to review that documentation to familiarize yourself with all available Slack Dialog elements. Finally, the state transitions to Await_Additional_Info which will receive the response from the dialog. The above configuration handles sending a dialog and receiving the response. However, since the response may either be a submission or cancellation, we need a choice state to examine the response and guide our execution. That's what Did_User_Submit_Dialog will do. Let's configure that choice state as shown below: \"Did_User_Submit_Dialog\": { \"Type\": \"Choice\", \"Choices\": [ { \"Variable\": \"$.results.Await_Additional_Info.type\", \"StringEquals\": \"dialog_submission\", \"Next\": \"Reassure_User\" }, { \"Variable\": \"$.results.Await_Additional_Info.type\", \"StringEquals\": \"dialog_cancellation\", \"Next\": \"Update_Bat_Signals_Channel\" } ] } The state checks the data at $.results.Await_Additional_Info.type to determine what action was taken on the dialog i.e. dialog_submission or dialog_cancellation. If the dialog was submitted, it transitions to Reassure_User which is already configured in our playbook. If the dialog was cancelled, it transitions to Update_Bat_Signals_Channel . Let's configure that state as shown below: \"Update_Bat_Signals_Channel\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.slack.SendMessage}}\", \"Parameters\": { \"target\": \"bat-signals\", \"target_type\": \"channel\", \"message_template\": \"User, {context.artifacts.event.details.username}, reported that they did not log into their account but also failed to provide additional details via the dialog. Please investigate.\" }, \"End\": true } The configuration uses the Socless Slack SendMessage integration to update the bat-signals channel that the dialog requesting additional information wasn't submitted. It then ends the playbook execution. Deploy the playbook and execute our test case located in the investigate_login folder. Run through all the possible flows of the playbook to get an idea of the user experience. You'll probably identify a number of places where the experience can be improved (e.g. providing a feedback message to the user after they cancel the dialog). Feel free to tackle these improvements to practice what you've learned. With that addition, you've successfully written a playbook that interacts with a human using message buttons and dialogs! Congratulations \ud83c\udf7e \ud83c\udf7e That's all for this tutorial series. In future tutorials, we'll cover: Executing Lambda Integrations in Parallel, Using Pass States to label branches on your playbook to improve legibility Leveraging Socless' Deduplication Mechanism to Handle Duplicate Events","title":"Collect Information Using a Slack Dialog"},{"location":"deploy-socless-slack/","text":"Deploy Socless Slack Integrations Socless Slack is a set of integrations and endpoints for enabling human interactions via Slack. Socless Slack includes functionality for: Prompting a user to answer yes-no questions for interactive buttons Requesting detailed information using dialogs Collecting information via Slack slash command entry Follow the instructions in the socless-slack README to deploy and configure credentials for Socless Slack. Reference Socless Slack Integrations in Socless Playbook Repository Next, let's update the serverless.yml file of our socless-playbooks repository with references to the integrations provided by Socless Slack. If you no longer have the socless-playbooks repository we created in the Getting Started tutorial, you can download it from the Socless Examples repo Open up the serverless.yml file for your socless-playbooks repo and nest the below configurations one indentation level below the custom object slack: PromptForConfirmation: ${{cf:socless-slack-${{self:provider.stage}}.PromptForConfirmation}} PromptForResponse: ${{cf:socless-slack-${{self:provider.stage}}.PromptForResponse}} SendMessage: ${{cf:socless-slack-${{self:provider.stage}}.SendMessage}} FindUser: ${{cf:socless-slack-${{self:provider.stage}}.FindUser}} SendDialog: ${{cf:socless-slack-${{self:provider.stage}}.SendDialog}} The configuration references the five Lambda integrations currently made available by Socless Slack. We'll use them shortly Once the configuration is saved, head to the next page for an overview of SOCless' Human Interaction Workflow","title":"Deploy Socless Slack"},{"location":"deploy-socless-slack/#deploy-socless-slack-integrations","text":"Socless Slack is a set of integrations and endpoints for enabling human interactions via Slack. Socless Slack includes functionality for: Prompting a user to answer yes-no questions for interactive buttons Requesting detailed information using dialogs Collecting information via Slack slash command entry Follow the instructions in the socless-slack README to deploy and configure credentials for Socless Slack.","title":"Deploy Socless Slack Integrations"},{"location":"deploy-socless-slack/#reference-socless-slack-integrations-in-socless-playbook-repository","text":"Next, let's update the serverless.yml file of our socless-playbooks repository with references to the integrations provided by Socless Slack. If you no longer have the socless-playbooks repository we created in the Getting Started tutorial, you can download it from the Socless Examples repo Open up the serverless.yml file for your socless-playbooks repo and nest the below configurations one indentation level below the custom object slack: PromptForConfirmation: ${{cf:socless-slack-${{self:provider.stage}}.PromptForConfirmation}} PromptForResponse: ${{cf:socless-slack-${{self:provider.stage}}.PromptForResponse}} SendMessage: ${{cf:socless-slack-${{self:provider.stage}}.SendMessage}} FindUser: ${{cf:socless-slack-${{self:provider.stage}}.FindUser}} SendDialog: ${{cf:socless-slack-${{self:provider.stage}}.SendDialog}} The configuration references the five Lambda integrations currently made available by Socless Slack. We'll use them shortly Once the configuration is saved, head to the next page for an overview of SOCless' Human Interaction Workflow","title":"Reference Socless Slack Integrations in Socless Playbook Repository"},{"location":"deploying-socless/","text":"Introduction Socless is deployed using the Serverless Framework . Socless uses the Serverless Framework as its orchestration technology. All the core infrastructure that powers Socless is deployed via a single Serverless Framework application. Additional functionality (Playbooks, Integrations, Endpoints, etc) are deployed via their own Serverless Framework applications. This means that Socless is designed to be modular and is deployed as such. In this documentation, we'll deploy Socless' core infrastructure. Later documentation will cover the deployment of additional Socless modules like integrations. Pre-requisites An AWS Account The Serverless Framework installed The aws-cli installed An aws-cli profile configured with access keys Python 3.7, pip and git Once the pre-requisites have been successfully set up, move to the next section Clone socless Start by cloning the Socless repository to any directory on your local machine that you've designated for code projects using the command below: git clone git@github.com:twilio-labs/socless.git Change into the cloned directory and install the deployment dependencies by running the below command npm install Finally, setup and activate a Python3.7 virtual environment using the commands below. virtualenv --python=python3.7 venv . venv/bin/activate Keep the virtual environment active for the rest of the tutorial Specify AWS Profile Open the package.json file contained in the cloned folder. In the config object, set the aws_profile value to match the name of the AWS CLI profile you configured at the start of the guide. For example, If your configured profile was named default , the config object should look like this: \"config\":{ \"aws_profile\": \"default\", \"dev\": \"--stage dev --region us-west-2\", \"prod\": \"--stage prod --region us-east-1\" } (Optional) Modify Development/Production environment Config By default, Socless supports a development and production environment. The development environment, (dev) is set to AWS us-west-2 region, and the Production environment (prod) is AWS us-east-1 region. If you do not wish to change the deployment regions, you can skip to Deploy section. If you want to use different regions for dev/prod, change the region specified for them in the config object. For example, the below config uses us-east-2 for dev and us-west-2 for prod. \"config\":{ \"aws_profile\": \"default\", \"dev\": \"--stage dev --region us-east-2\", \"prod\": \"--stage prod --region us-west-2\" } However, before changing regions, we recommend you review the AWS Region Table to ensure that the region you want to use supports all AWS services you may want to integrate with down the line (e.g Amazon SES) Deploy socless to dev/prod Run the following command within the socless directory to deploy socless dev environment: npm run dev Run the following command within socless directory to deploy socless prod environment: npm run prod Both commands are used to deploy AND redeploy Socless to the dev and prod environments respectively after changes have been made. Review the Deployment Output The Serverless Framework deploys applications to AWS using the AWS Cloudformation service. Each Serverless application is deployed as a CloudFormation Stack. If the Socless deployment succeeded, your terminal should show Cloudformation Stack Outputs of the deployed resources. Additionally, if you log into the AWS console and navigate to the Cloudformation service in the region you deployed Socless to, you should find a Cloudformation stack named `socless- With Socless successfully deployed, you're ready to write your first playbook","title":"Deploying Socless"},{"location":"deploying-socless/#introduction","text":"Socless is deployed using the Serverless Framework . Socless uses the Serverless Framework as its orchestration technology. All the core infrastructure that powers Socless is deployed via a single Serverless Framework application. Additional functionality (Playbooks, Integrations, Endpoints, etc) are deployed via their own Serverless Framework applications. This means that Socless is designed to be modular and is deployed as such. In this documentation, we'll deploy Socless' core infrastructure. Later documentation will cover the deployment of additional Socless modules like integrations. Pre-requisites An AWS Account The Serverless Framework installed The aws-cli installed An aws-cli profile configured with access keys Python 3.7, pip and git Once the pre-requisites have been successfully set up, move to the next section","title":"Introduction"},{"location":"deploying-socless/#clone-socless","text":"Start by cloning the Socless repository to any directory on your local machine that you've designated for code projects using the command below: git clone git@github.com:twilio-labs/socless.git Change into the cloned directory and install the deployment dependencies by running the below command npm install Finally, setup and activate a Python3.7 virtual environment using the commands below. virtualenv --python=python3.7 venv . venv/bin/activate Keep the virtual environment active for the rest of the tutorial","title":"Clone socless"},{"location":"deploying-socless/#specify-aws-profile","text":"Open the package.json file contained in the cloned folder. In the config object, set the aws_profile value to match the name of the AWS CLI profile you configured at the start of the guide. For example, If your configured profile was named default , the config object should look like this: \"config\":{ \"aws_profile\": \"default\", \"dev\": \"--stage dev --region us-west-2\", \"prod\": \"--stage prod --region us-east-1\" }","title":"Specify AWS Profile"},{"location":"deploying-socless/#optional-modify-developmentproduction-environment-config","text":"By default, Socless supports a development and production environment. The development environment, (dev) is set to AWS us-west-2 region, and the Production environment (prod) is AWS us-east-1 region. If you do not wish to change the deployment regions, you can skip to Deploy section. If you want to use different regions for dev/prod, change the region specified for them in the config object. For example, the below config uses us-east-2 for dev and us-west-2 for prod. \"config\":{ \"aws_profile\": \"default\", \"dev\": \"--stage dev --region us-east-2\", \"prod\": \"--stage prod --region us-west-2\" } However, before changing regions, we recommend you review the AWS Region Table to ensure that the region you want to use supports all AWS services you may want to integrate with down the line (e.g Amazon SES)","title":"(Optional) Modify Development/Production environment Config"},{"location":"deploying-socless/#deploy-socless-to-devprod","text":"Run the following command within the socless directory to deploy socless dev environment: npm run dev Run the following command within socless directory to deploy socless prod environment: npm run prod Both commands are used to deploy AND redeploy Socless to the dev and prod environments respectively after changes have been made.","title":"Deploy socless to dev/prod"},{"location":"deploying-socless/#review-the-deployment-output","text":"The Serverless Framework deploys applications to AWS using the AWS Cloudformation service. Each Serverless application is deployed as a CloudFormation Stack. If the Socless deployment succeeded, your terminal should show Cloudformation Stack Outputs of the deployed resources. Additionally, if you log into the AWS console and navigate to the Cloudformation service in the region you deployed Socless to, you should find a Cloudformation stack named `socless- With Socless successfully deployed, you're ready to write your first playbook","title":"Review the Deployment Output"},{"location":"faqs/","text":"FAQs How does SOCless enhance AWS Step Functions for security automation? AWS Step Functions is an extremely versatile service for automating workflows across many industries and use-cases. Industry-leading companies have used AWS Step Functions to transcode videos, manage subscription billing workloads and build data pipelines for business analytics . SOCless enhances AWS Step Functions with architectures, code libraries and helper tools that tackle common, security automation specific challenges such as processing alerts, accessing internal network resources securely, interacting with humans via bots, and so much more. How does SOCless differ from other security automation frameworks? SOCless is completely serverless. You can deploy and scale your security processes without worrying about server management. Its serverless implementation means you only pay for what you use, allowing you automate at low cost. In addition, SOCless is 100% open-source, extensible and community-driven.","title":"FAQs"},{"location":"faqs/#faqs","text":"","title":"FAQs"},{"location":"faqs/#how-does-socless-enhance-aws-step-functions-for-security-automation","text":"AWS Step Functions is an extremely versatile service for automating workflows across many industries and use-cases. Industry-leading companies have used AWS Step Functions to transcode videos, manage subscription billing workloads and build data pipelines for business analytics . SOCless enhances AWS Step Functions with architectures, code libraries and helper tools that tackle common, security automation specific challenges such as processing alerts, accessing internal network resources securely, interacting with humans via bots, and so much more.","title":"How does SOCless enhance AWS Step Functions for security automation?"},{"location":"faqs/#how-does-socless-differ-from-other-security-automation-frameworks","text":"SOCless is completely serverless. You can deploy and scale your security processes without worrying about server management. Its serverless implementation means you only pay for what you use, allowing you automate at low cost. In addition, SOCless is 100% open-source, extensible and community-driven.","title":"How does SOCless differ from other security automation frameworks?"},{"location":"getting-started/","text":"This tutorial will take you through the basics of creating your first automated response plan in Socless. In Socless, automated response plans are called playbooks. Our first playbook will respond to an alert of an anomalous login. The alert will contain the username of the account that was logged into and the IP that logged into it. Our playbook, which will be called \"InvestigateLogin\", will respond to the alert by geolocating the IP address and posting the findings to a Slack channel. To accomplish this, we will: Create one Socless Integration that handles IP geolocation and another that can send a slack message Create a playbook that uses the above Integrations to respond for our alert Create a Socless Endpoint that knows how to process our alert and trigger our playbook Here's a diagram that shows how all the components we will create fit together to respond to our alert [ diagram coming soon ] Head to the next page to create your first integration","title":"Getting Started Tutorial"},{"location":"human-interaction-architecture/","text":"Human Interaction Architecture Reference Hey there! You've landed on a documentation page we're yet to create. If you need this documentation page ASAP, please help us prioritize it by creating an issue on our Github project at https://github.com/twilio-labs/socless","title":"Human Interaction Architecture"},{"location":"human-interaction-architecture/#human-interaction-architecture-reference","text":"Hey there! You've landed on a documentation page we're yet to create. If you need this documentation page ASAP, please help us prioritize it by creating an issue on our Github project at https://github.com/twilio-labs/socless","title":"Human Interaction Architecture Reference"},{"location":"human-interaction-overview/","text":"Socless' Human Interaction Workflow enables the incorporation of human input into your playbooks. Using the tools provided by the workflow, Socless developers can create playbooks that interact with users via messaging channels like Slack. The Human Interaction Workflow is used by configuring an Interaction state in a playbook. Interaction states are configured the same way as Task state, with the difference being that Interaction states have their Type set to Interaction The Human Interaction Architecture documentation provides an in-depth explanation of how human interactions work in Socless and how you can build your own. For now, we'll focus on using Socless Slack (which implements human interaction in Slack) to augment our Getting Started playbook. Let's start by including functionality to prompt a user for confirmation","title":"Human Interaction Overview"},{"location":"key-concepts-and-terms/","text":"Key Concepts and Terms Below are key concepts and terms to help you get started with SOCless: Playbooks : The automated processes you create. Playbooks contain a series of coordinated steps that work towards an end goal. They are written in JSON AWS Step Functions : The AWS service that manages playbook executions. State : A single step in a playbook. States can take actions, evaluate choices, parallelize actions, wait for time periods, or aid debugging of playbooks. Integrations : AWS Lambda functions that integrate with your existing security products. States use integrations to take actions in playbooks. Integrations are written in Python. The term may refer to a single function, or a group of functions related to the same product. Event Endpoints : AWS Lambda functions that process incoming events and trigger playbook executions. Event Triggers : Services that trigger event endpoints. Currently tested event triggers include AWS API Gateway for http-based alerts, and AWS CloudWatch for scheduled events. However, any service that can trigger an AWS Lambda function may serve as an event trigger. Event Table : The AWS DynamoDB table that stores event data. Event endpoints create events in the Event Table. Execution Results Table . The AWS DynamoDB table that stores playbook execution data. Integrations read input and write outputs to the Execution Results Table as they perform actions during a playbook's execution. socless_python : The Python library that manages the execution life-cycle of integrations and event endpoints, making them simple to write, reuse and share.","title":"Key Concepts and Terms"},{"location":"key-concepts-and-terms/#key-concepts-and-terms","text":"Below are key concepts and terms to help you get started with SOCless: Playbooks : The automated processes you create. Playbooks contain a series of coordinated steps that work towards an end goal. They are written in JSON AWS Step Functions : The AWS service that manages playbook executions. State : A single step in a playbook. States can take actions, evaluate choices, parallelize actions, wait for time periods, or aid debugging of playbooks. Integrations : AWS Lambda functions that integrate with your existing security products. States use integrations to take actions in playbooks. Integrations are written in Python. The term may refer to a single function, or a group of functions related to the same product. Event Endpoints : AWS Lambda functions that process incoming events and trigger playbook executions. Event Triggers : Services that trigger event endpoints. Currently tested event triggers include AWS API Gateway for http-based alerts, and AWS CloudWatch for scheduled events. However, any service that can trigger an AWS Lambda function may serve as an event trigger. Event Table : The AWS DynamoDB table that stores event data. Event endpoints create events in the Event Table. Execution Results Table . The AWS DynamoDB table that stores playbook execution data. Integrations read input and write outputs to the Execution Results Table as they perform actions during a playbook's execution. socless_python : The Python library that manages the execution life-cycle of integrations and event endpoints, making them simple to write, reuse and share.","title":"Key Concepts and Terms"},{"location":"making-choices-in-playbooks/","text":"Robust response plans are seldom linear; seasoned responders expect their actions and investigations to generate new insights that require a slight change of tactics. Courtesy of AWS Step Functions, Socless is equipped with Choice States that allow playbooks to choose the right path of execution based on the results of a prior action. In this tutorial, we'll learn how to configure a Choice state in a playbook. Specifically, we'll configure our playbook to: Thank the user if they indicate they performed the login by clicking \"yes\", OR Inform the user that help is on the way if they weren't responsible for the login Start by removing the Post_Update_To_Bat_Signals state from the investigate_login Playbook. Delete both the state name and configuration object. Then, change the Next transition of the Await_User_Verification state to Did_User_Login . Did_User_Login will be the name of our Choice state. Configure Did_User_Login as shown below. We'll talk through the config in a moment \"Did_User_Login\": { \"Type\": \"Choice\", \"Choices\": [ { \"Variable\": \"$.results.Await_User_Verification.actions.value\", \"StringEquals\": \"yes\", \"Next\": \"Thank_User\" }, { \"Variable\": \"$.results.Await_User_Verification.actions.value\", \"StringEquals\": \"no\", \"Next\": \"Reassure_User\" } ] } Since Did_User_Login is a Choice state, the Type is set to Choice . The primary configurable for a Choice state is a list of Choices . Each item in the list is an object that represents a Choice rule; a condition to be evaluated and selected if true. Each Choice Rule consists of three components: a variable --contained within our Playbook Context Object-- to evaluate, the comparison to perform, and the state to transition to if the comparison evaluates to True . The 'Variable' the Choice state checks against is specified using a Parameter Reference -- exactly the way you'd pass a parameter to an Integration. However, unlike an Integration, A Choice State can only reference parameters from the immediately preceding state i.e the state that transitioned to it. You can learn more about that in the State Management In Socless documentation . For now, the key thing to remember is that Choice states need to be configured after the state that generates the data being evaluated. The Comparison expresses the type of check to perform against the 'Variable'. Choice Rules support different types of comparisons such as StringEquals , BooleanEquals , NumericEquals and more. For a full list of the supported comparisons, refer to the AWS Step Functions Choice State documentation Finally, the 'Next' transition functions exactly as it does in Integrations. The Choice Rules in the Choices list are evaluated in order. The first choice that evaluates to true determines what state the playbook will be transitioned to next. The above Choice Rules checks the variable $.results.Await_User_Verification.actions.value to see if it is a string that's either equal to \"yes\" or \"no\". If the string is equal to \"yes\", the Choice state transitions to the Thank_User state. If it's \"no\", it transitions to the Reassure_User state. Let's go ahead and configure both states. Both Thank_User and Reassure_User will use the Socless Slack SendMessage integration to message the user based on their response. Here are their configurations: \"Thank_User\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.slack.SendMessage}}\", \"Parameters\": { \"target\": \"$.artifacts.event.details.username\", \"target_type\": \"user\", \"message_template\": \"Thanks for the confirmation! I'll let the security team know everything is fine\" }, \"End\": true }, \"Reassure_User\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.slack.SendMessage}}\", \"Parameters\": { \"target\": \"$.artifacts.event.details.username\", \"target_type\": \"user\", \"message_template\": \"Oh oh. Seems like something is amiss here. I'll inform the security team immediately\" }, \"End\": true } Once you've included these configurations in your States object, redeploy the playbook then test it again. After answering the message prompt you receive, you'll receive another Slack message that differs based on the response you selected. Be sure to test both parts in your execution. And that's it. You've successfully configured a choice state in your playbook. Let's move on to the next tutorial and learn how to Collect Information using a Slack Dialog","title":"Making Choices in Playbooks"},{"location":"parameter-references-and-template-variables/","text":"Hey there! You've landed on a documentation page we're yet to create. If you need this documentation page ASAP, please help us prioritize it by creating an issue on our Github project at https://github.com/twilio-labs/socless","title":"Parameter References & Template Variables"},{"location":"prompting-a-user-for-confirmation/","text":"Open the InvestigateLogin playbook in your socless-playbooks repository. The playbook is at the path playbooks/investigate_login/playbook.json Take a second to review and admire the playbook. Currently, it starts at a Geolocate_IP state and ends at a Notify_Bat_Signals_Channel state. Modify Notify_Bat_Signals_Channel to transition to a state called Verify_Login_With_User . Do with by changing the transition configuration for Notify_Bat_Signals_Channel from \"End\": true to \"Next\": \"Verify_Login_With_User\" . Next, add the below Interaction state to your States object. \"Verify_Login_With_User\": { \"Type\": \"Interaction\", \"Resource\": \"${{self:custom.slack.PromptForConfirmation}}\", \"Parameters\": { \"target\": \"$.artifacts.event.details.username\", \"target_type\": \"user\", \"text\": \"Hi {context.artifacts.event.details.username}, I noticed that your account was logged into from {context.results.Geolocate_IP.country}\", \"prompt_text\": \"Did you login from {context.results.Geolocate_IP.country}?\" }, \"Next\": \"Post_Update_To_Bat_Signals\" } The state, which is called Verify_Login_With_User , uses the Lambda Integration, PromptForConfirmation, to send a yes-no button prompt to the user. It accepts the parameters: target : the Slack entity being messaged target_type : The type of Slack entity being messaged (in this case, a user) text : The initial message to prompt_text : The text that asks as a subject line for the yes-no prompt receiver : The name of the state in the playbook that will receive the response (in this case Await_User_Verification) \"Post_Update_To_Bat_Signals\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.slack.SendMessage}}\", \"Parameters\": { \"target\": \"bat-signals\", \"target_type\": \"channel\", \"message_template\": \"User, `{context.artifacts.event.details.username}` responded `{context.results.Verify_Login_With_User.actions.value}` to the alert\" }, \"End\": true } Post_Update_To_Bat_Signals uses the Socless Slack SendMessage integration to send a message to the channel. This SendMessage integration is identical to the one we created in the Getting Started tutorial . We pass it the #bat-signals channel and the templatized message to send. Pay attention to the {results.Verify_Login_With_User.actions.value} variable in the message template. When a SOCless Slack message button is pushed, the result is returned in a dictionary that contains, amongst other things, information about what button was pushed. The information is stored at *.actions.value and is the string \"true\" if yes was pressed, or \"false\" if no was pressed. In the next tutorial, we'll learn how to use that information to guide the execution of our workflow. For now, let's test our updated playbook to see how it works. Testing our updates Since our playbook has already been listed in our socless-playbooks serverless.yml, we simply need to redeploy socless-playbooks to publish our updates. Do so by running the below command. Be sure to change dev to match the environment you're deploying to (for our tutorials, it should be dev) npm run dev Next, let's send an alert to the Event Endpoint from our Getting Started Tutorial. The alert payload is below: { \"alert_name\": \"Suspicious Login Detected\", \"response_plan\": \"InvestigateLogin\", \"details\": [ { \"username\": \"bruce.wayne\", \"ip\": \"113.63.125.3\" } ] } Change the username to your Slack username then save the payload to a test_case.json file in the investigate_login folder. Next, use the below curl command to send the payload to our Event Endpoint. Be sure to replace {endpoint-url} with your endpoint URL curl -X POST {endpoint-url} -d @playbooks/investigate_login/test_case.json If the request is successful, you'll receive a notice of an alert in the #bat-signals channel, and a message from the socless-bot asking you if you logged into your account from China. When you click either \"yes\" or \"no\" you'll see a new message in the #bat-signals channel with your response. Congratulations! You've successfully added human interactivity into your playbook! \ud83c\udf7e Move on to the next page of the tutorial to learn how to control the flow of your playbook based on a human's response","title":"Prompt a User for Confirmation"},{"location":"prompting-a-user-for-confirmation/#testing-our-updates","text":"Since our playbook has already been listed in our socless-playbooks serverless.yml, we simply need to redeploy socless-playbooks to publish our updates. Do so by running the below command. Be sure to change dev to match the environment you're deploying to (for our tutorials, it should be dev) npm run dev Next, let's send an alert to the Event Endpoint from our Getting Started Tutorial. The alert payload is below: { \"alert_name\": \"Suspicious Login Detected\", \"response_plan\": \"InvestigateLogin\", \"details\": [ { \"username\": \"bruce.wayne\", \"ip\": \"113.63.125.3\" } ] } Change the username to your Slack username then save the payload to a test_case.json file in the investigate_login folder. Next, use the below curl command to send the payload to our Event Endpoint. Be sure to replace {endpoint-url} with your endpoint URL curl -X POST {endpoint-url} -d @playbooks/investigate_login/test_case.json If the request is successful, you'll receive a notice of an alert in the #bat-signals channel, and a message from the socless-bot asking you if you logged into your account from China. When you click either \"yes\" or \"no\" you'll see a new message in the #bat-signals channel with your response. Congratulations! You've successfully added human interactivity into your playbook! \ud83c\udf7e Move on to the next page of the tutorial to learn how to control the flow of your playbook based on a human's response","title":"Testing our updates"},{"location":"socless-and-serverless/","text":"Hey there! You've landed on a documentation page we're yet to create. If you need this documentation page ASAP, please help us prioritize it by creating an issue on our Github project at https://github.com/twilio-labs/socless","title":"Socless & Serverless"},{"location":"socless-architecture/","text":"SOCless Architecture [ ]","title":"SOCless Architecture"},{"location":"socless-architecture/#socless-architecture","text":"[ ]","title":"SOCless Architecture"},{"location":"socless-vs-stock-stepfunctions/","text":"Hey there! You've landed on a documentation page we're yet to create. If you need this documentation page ASAP, please help us prioritize it by creating an issue on our Github project at https://github.com/twilio-labs/socless","title":"SOCless vs Stock AWS Step Functions"},{"location":"state-management-in-socless/","text":"State Management in SOCless Hey there! You've landed on a documentation page we're yet to create. If you need this documentation page ASAP, please help us prioritize it by creating an issue on our Github project at https://github.com/twilio-labs/socless","title":"State Management in SOCless"},{"location":"state-management-in-socless/#state-management-in-socless","text":"Hey there! You've landed on a documentation page we're yet to create. If you need this documentation page ASAP, please help us prioritize it by creating an issue on our Github project at https://github.com/twilio-labs/socless","title":"State Management in SOCless"},{"location":"test-your-first-playbook/","text":"To test our playbook, we'll use curl to send our alert. You may use any other HTTP request sending tool you\u2019re comfortable with. Here's the alert payload we'll be sending { \"alert_name\": \"Suspicious Login Detected\", \"response_plan\": \"InvestigateLogin\", \"details\": [ { \"username\": \"bruce.wayne\", \"ip\": \"113.63.125.3\" } ] } If you\u2019re sticking with curl, save that payload in the investigate_login folder in a file called test_case.json . Then execute the below curl command from the root of your socless-playbooks repository to send the payload to your Event Endpoint. Be sure to replace {endpoint-url} with your action endpoint URL. curl -X POST {endpoint-url} -d @playbooks/investigate_login/test_case.json Once the request completes, you should receive a message in the #bat-signals channel. Furthermore, the AWS Step Functions console will show the execution history for your playbook. Congratulations! You've successfully completed your first playbook \ud83c\udf7e Keep on learning by heading to the tutorial on Interacting with Humans in Slack","title":"Test Your First Playbook"},{"location":"tutorial-interacting-with-humans-via-slack/","text":"This tutorial expands on the Getting Started Tutorial to introduce you to more advanced playbook development concepts. Specifically, you'll learn how to: Interact with humans using Socless' Human Interaction Workflow and Slack Integrations Add branching logic to our State Machine using Choice Make our playbooks more legible using Pass States In our Getting Started Tutorial, we wrote a playbook called \"Investigate Login\" that handled a \"Suspicious Login\" alert by: Geolocating the Login IP to identify its country, latitude, and longitude Posting a message containing that information to a #bat-signals channel in Slack In this tutorial, we'll expand that playbook to: Prompt a user to confirm or denounce the login activity via Slack message buttons Request more details on the activity via a Slack interactive dialog Notify the user of the actions that will be taken based on their response The workflow for the playbook we'll create in this tutorial is shown below [diagram coming soon] Let's start by deploying Socless Slack , which contains the integrations we'll use in this tutorial","title":"Interacting With Humans via Slack"},{"location":"your-first-endpoint/","text":"Your First Endpoint Socless uses Event Endpoints to receive event/alert data from external systems and trigger playbooks. At their core, Event Endpoints are simply AWS Lambda functions that invoke the create_events function from the socless Python library with the information necessary to register the event within Socless and trigger the appropriate playbook. As such, the bare-bones, psuedo-code implementation for any Socless Event Endpoint looks like this: from socless import create_events def lambda_handler(event, context): # Populate event_details object with approriate fields event_details = { 'event_type': '...', # event name 'playbook': '...', # playbook name 'details': [{'...'},{'...'}] # alert findings } # Invoke create_events function with event_details create_events(event_details, context) return {\"statusCode\": 200} The create_events function takes two parameters: event_details and context . context is the AWS Lambda context which all Lambda functions receive when they are executed by AWS. It\u2019s passed to the create_events function without any modification. event_details is a dictionary constructed by the developer of the Event Endpoint that must contain the below key-value pairs: Key Type Description Required? Example Value event_type string The unique event name Yes Anomalous Login IP Detected details list of dicts List of dictionaries containing aggregated findings for the event type Yes [{\"username\": \"bruce.wayne\",\"ip\": \"113.63.125.3\"}] playbook string The Playbook to execute for the event Yes InvestigateLogin For our tutorial, all the values needed to populate the event_details dictionary are conveniently contained in the alert payload our detection system will send. So the implementation for our tutorial endpoint will look like this: from socless import create_events import json def lambda_handler(event, context): alert_payload = json.loads(event['body']) event_details = { 'event_type': alert_payload['alert_name'], 'playbook': alert_payload['response_plan'], 'details': alert_payload['details'] } try: create_events(event_details, context) except Exception as e: return {\"statusCode\": 400, \"body\": f\"{e}\"} return {\"statusCode\": 200} Include this implementation in the lambda_function.py file in the tutorial_endpoint folder. Note that the current implementation does not include an authentication mechanism to protect our endpoint. Authentication for endpoints will be discussed in the Event Endpoints reference documentation here. For now, we\u2019ll keep our endpoint simple and include authentication later in our tutorial. With the logic for our Event Endpoint implemented, we\u2019re ready to configure it for deployment Configuring our Event Endpoint for Deployment Much like Socless\u2019 core infrastructure, Event Endpoints are deployed as Serverless Framework applications. Since we created our socless-tutorial folder using the socless-integrations-template , it is already pre-configured with much of the information we need to deploy our Event Endpoint (the current pre-configurations will be explained in the socless-integrations-template reference documentation here). All we need do now is add configurations for the tutorial_endpoint function we just created. Open the serverless.yml file contained within our socless-tutorial folder. This file is where configurations for our socless-tutorial Serverless application lives. At the bottom of the file , let\u2019s configure a lambda function that: is reference-able in our config as TutorialEndpoint is named _socless_tutorial_endpoint has its entry point (handler) at lambda_function.lambda_handler has the description: \u201cReceives alerts from our tutorial detection system\u201d creates its source package from the contents of the functions/tutorial_endpoint folder of our socless-tutorial folder is triggered by an http POST request to the /endpoints/tutorial path of Socless\u2019 API endpoint Here\u2019s what that configuration looks like: TutorialEndpoint: name: _socless_tutorial_endpoint handler: lambda_function.lambda_handler description: Receives alerts from our tutorial detection system package: include: - functions/tutorial_endpoint events: - http: path: /tutorial method: post We are now ready to deploy and test our endpoint. Deploy The Endpoint Since we\u2019re still in the development phase, we\u2019ll only deploy the event endpoint to our Socless dev environment. Do so by running the below command npm run dev Once the deployment is successful, you will find a URL that ends in /tutorial in the Service Information section. This is the URL for the endpoint we just deployed. It\u2019s where our tutorial detection system will send our alert payload. Keep it handy. We'll need it to test the playbook","title":"Your First Endpoint"},{"location":"your-first-endpoint/#your-first-endpoint","text":"Socless uses Event Endpoints to receive event/alert data from external systems and trigger playbooks. At their core, Event Endpoints are simply AWS Lambda functions that invoke the create_events function from the socless Python library with the information necessary to register the event within Socless and trigger the appropriate playbook. As such, the bare-bones, psuedo-code implementation for any Socless Event Endpoint looks like this: from socless import create_events def lambda_handler(event, context): # Populate event_details object with approriate fields event_details = { 'event_type': '...', # event name 'playbook': '...', # playbook name 'details': [{'...'},{'...'}] # alert findings } # Invoke create_events function with event_details create_events(event_details, context) return {\"statusCode\": 200} The create_events function takes two parameters: event_details and context . context is the AWS Lambda context which all Lambda functions receive when they are executed by AWS. It\u2019s passed to the create_events function without any modification. event_details is a dictionary constructed by the developer of the Event Endpoint that must contain the below key-value pairs: Key Type Description Required? Example Value event_type string The unique event name Yes Anomalous Login IP Detected details list of dicts List of dictionaries containing aggregated findings for the event type Yes [{\"username\": \"bruce.wayne\",\"ip\": \"113.63.125.3\"}] playbook string The Playbook to execute for the event Yes InvestigateLogin For our tutorial, all the values needed to populate the event_details dictionary are conveniently contained in the alert payload our detection system will send. So the implementation for our tutorial endpoint will look like this: from socless import create_events import json def lambda_handler(event, context): alert_payload = json.loads(event['body']) event_details = { 'event_type': alert_payload['alert_name'], 'playbook': alert_payload['response_plan'], 'details': alert_payload['details'] } try: create_events(event_details, context) except Exception as e: return {\"statusCode\": 400, \"body\": f\"{e}\"} return {\"statusCode\": 200} Include this implementation in the lambda_function.py file in the tutorial_endpoint folder. Note that the current implementation does not include an authentication mechanism to protect our endpoint. Authentication for endpoints will be discussed in the Event Endpoints reference documentation here. For now, we\u2019ll keep our endpoint simple and include authentication later in our tutorial. With the logic for our Event Endpoint implemented, we\u2019re ready to configure it for deployment","title":"Your First Endpoint"},{"location":"your-first-endpoint/#configuring-our-event-endpoint-for-deployment","text":"Much like Socless\u2019 core infrastructure, Event Endpoints are deployed as Serverless Framework applications. Since we created our socless-tutorial folder using the socless-integrations-template , it is already pre-configured with much of the information we need to deploy our Event Endpoint (the current pre-configurations will be explained in the socless-integrations-template reference documentation here). All we need do now is add configurations for the tutorial_endpoint function we just created. Open the serverless.yml file contained within our socless-tutorial folder. This file is where configurations for our socless-tutorial Serverless application lives. At the bottom of the file , let\u2019s configure a lambda function that: is reference-able in our config as TutorialEndpoint is named _socless_tutorial_endpoint has its entry point (handler) at lambda_function.lambda_handler has the description: \u201cReceives alerts from our tutorial detection system\u201d creates its source package from the contents of the functions/tutorial_endpoint folder of our socless-tutorial folder is triggered by an http POST request to the /endpoints/tutorial path of Socless\u2019 API endpoint Here\u2019s what that configuration looks like: TutorialEndpoint: name: _socless_tutorial_endpoint handler: lambda_function.lambda_handler description: Receives alerts from our tutorial detection system package: include: - functions/tutorial_endpoint events: - http: path: /tutorial method: post We are now ready to deploy and test our endpoint.","title":"Configuring our Event Endpoint for Deployment"},{"location":"your-first-endpoint/#deploy-the-endpoint","text":"Since we\u2019re still in the development phase, we\u2019ll only deploy the event endpoint to our Socless dev environment. Do so by running the below command npm run dev Once the deployment is successful, you will find a URL that ends in /tutorial in the Service Information section. This is the URL for the endpoint we just deployed. It\u2019s where our tutorial detection system will send our alert payload. Keep it handy. We'll need it to test the playbook","title":"Deploy The Endpoint"},{"location":"your-first-integration-geolocating-an-ip/","text":"Your First Integration: Geolocate IP Socless uses Integrations to take actions within playbooks. An Integration is an AWS Lambda functions that uses the socless_bootstrap function from the Socless Python library to manage its execution life-cycle (i.e fetching its inputs and saving its outputs). Integrations typically integrate with 3rd party APIs \u2013 hence the name 'Integrations' \u2013 to accomplish a task. The bare-bones, pseudo-code implementation for any Socless integration is shown below from socless import socless_bootstrap def handle_state(param1, param2, \u2026): \"\"\"Core action logic goes here\"\"\" # Implement core actions (e.g api requests) and return dictionary with desired results return {\u2026} def lambda_handler(event, lambda_context): \"\"\"Handles life-cycle of handle_state\u2019s execution\"\"\" return socless_bootstrap(event, lambda_context, handle_state, include_event=False) The socless_bootstrap function takes the below parameters: Parameter Description Required? Default event Payload containing information the Integration needs to execute. Passed in either by an executing playbook or by a developer during testing. Yes N/A handle_state A function that implements the core logic of the Integration. Must return a dictionary Yes N/A include_event Boolean to specify if the whole playbook execution context (not lambda_context) should be made available to the handle_state function during its execution. Typically set to True for integrations that need to refer to elements of execution context in string templates. If True param1 of handle_state must be the keyword context No FALSE lambda_context The Lambda context object passed in by AWS whenever it triggers a Lambda function Yes N/A In this tutorial, we'll learn the basics of Integration development by writing one that geolocates an IP address and returns its country, latitude and longitude. Setting Up To begin, change out of socless directory at your command-line (if you\u2019re still within it) to a higher-level project folder. Next, run the commands below to download the socless-integrations-template which contains the pre-configurations we need for developing our Integration git clone git@github.com:twilio/socless-integrations-template.git socless-tutorial cd socless-tutorial ./setup virtualenv --python=python3.7 venv source venv/bin/activate The commands: clone the socless-integrations-template into a folder named socless-tutorial run a setup script that installs the development dependencies we need (serverless framework and relevant plugins) then deletes the setup script. create and activate a Python 3.7 virtual environment which will be used to package our Integration when we're ready to deploy it. After running the commands, you should be left with a socless-tutorial directory that contains a functions folder. This folder is where the code for our tutorial Integrations will live. Now that we're setup, let's code our Integration Coding the GeoIP Integration For IP address geolocation, we\u2019ll rely on https://tools.keycdn.com/geo.json which is a free geolocation API that requires no auth keys. This allows us keep things simple. Click the link to get an idea of the data the API returns. The geolocation logic for our integration will: be implemented in a handle_state function that only needs an IP as a parameter. use the python requests library to perform a GET request to https://tools.keycdn.com/geo.json with the url parameter host={ip} return a dictionary containing the country name, city name, latitude and longitude of the IP address. Our Integration will have a lambda_handler function that serves as AWS Lambda's entry point for our integration invokes socless_bootstrap to manage its life-cycle return the results of socless_bootstrap Here\u2019s what the implementation of the integration described above looks like import requests from socless import socless_bootstrap def handle_state(ip): r = requests.get(\"https://tools.keycdn.com/geo.json\", params={\"host\": ip}) geoip_info = r.json()['data']['geo'] desired_results = { \"country\": geoip_info['country_name'], \"latitude\": str(geoip_info['latitude']), \"longitude\": str(geoip_info['longitude']) } return desired_results def lambda_handler(event, context): return socless_bootstrap(event, context, handle_state) In the socless-tutorial/functions directory, create a subdirectory called geoip and save the implementation in a file called lambda_function.py . That\u2019s all the code we need to write for our Integrations logic. Specify Dependencies Notice that our integration makes use of the Python requests library which isn\u2019t one of the libraries pre-packaged with AWS Lambda. As such, we\u2019ll need to specify requests as a dependency with our deployment package. To do so, open the pre-existing requirements.txt file in the functions directory, and add requests at the bottom of the file. Your file should end up looking like this: git+https://github.com/twilio-labs/socless_python.git#egg=socless requests The first dependency in the file is the Socless Python library that provides the socless_bootstrap function. Any dependency listed in the functions/requirements.txt file gets deployed will all functions in the functions folder. To learn more about configuring dependencies for functions, visit the Socless & Serverless documentation page Our integration\u2019s implementation is complete and our dependencies have been specified. The last thing we need to do is configure the function for deployment. Configuring our integration for Deployment Socless Integrations are deployed using the Serverless Framework. To deploy our integration, open the serverless.yml file and configure a function that: is reference-able in our config as GeoIP is named socless_tutorial_geoip has a handler at lambda_function.lambda_handler has the description: \"Integration to geolocate an IP address\" creates its source package from functions/geoip Here's what that configuration looks like: functions: GeoIP: name: socless_tutorial_geoip handler: lambda_function.lambda_handler description: Integration to geolocate an ip package: include: - functions/geoip Next, we need to ensure that the AWS ARN of the function is output from the deployment stack after deployment. Doing so will allow the arn to be referenced by the playbook we will write shortly. To accomplish this, include the below configuration in the serverless.yml file, starting on the same indentation level as the functions key-word in the file resources: Outputs: GeoIP: Description: ARN of GeoIP integration Value: Fn::Sub: ${GeoIPLambdaFunction.Arn} With that, our Integration is fully configured for deployment. Deploying the Integration If your Python 3.7 virtual environment is no longer active, reactivate it by running the command . venv/bin/activate from within your socless-tutorial directory. Now, deploy the integration be executing: npm run dev Once the deployment is complete, you should see the ARN for the Integration's Lambda function displayed. You don't need to note this ARN down as we'll reference it by the GeoIP name whenever we need it. Testing the Integration Log into the AWS console, navigate to the Lambda service in your Socless dev region, and open the Lambda function for the integration we just deployed (socless_tutorial_geoip). Click Test , and configure the below test event: { \"_testing\": true, \"State_Config\": { \"Name\": \"Test_State\", \"Parameters\": { \"ip\": \"113.63.125.3\" } } } Observe that the key-value pair in the Parameters object maps exactly to the parameters we specified for the handle_state function of our integration. This test event simulates a small subset of the data that the integration would receive when it's called by an actual playbook execution. Give the test event any name of your choosing then hit create. Once the test event is created, click Test to test the integration. If the test executes successfully, you'll have an Execution result like below which shows the test event and the resulting geolocated IP in a results object. { \"_testing\": true, \"State_Config\": { \"Name\": \"Test_State\", \"Parameters\": { \"ip\": \"113.63.125.3\" } }, \"results\": { \"country\": \"China\", \"latitude\": '29.65', \"longitude\": '91.1' } } Feel free to change the IP address in your test case and play around a little. Conclusion Congratulations! You've written, deployed and tested your first integration! Pat yourself on the back, take a breather, then head to the next page to write your second integration","title":"Your First Integration: Geolocating an IP"},{"location":"your-first-integration-geolocating-an-ip/#your-first-integration-geolocate-ip","text":"Socless uses Integrations to take actions within playbooks. An Integration is an AWS Lambda functions that uses the socless_bootstrap function from the Socless Python library to manage its execution life-cycle (i.e fetching its inputs and saving its outputs). Integrations typically integrate with 3rd party APIs \u2013 hence the name 'Integrations' \u2013 to accomplish a task. The bare-bones, pseudo-code implementation for any Socless integration is shown below from socless import socless_bootstrap def handle_state(param1, param2, \u2026): \"\"\"Core action logic goes here\"\"\" # Implement core actions (e.g api requests) and return dictionary with desired results return {\u2026} def lambda_handler(event, lambda_context): \"\"\"Handles life-cycle of handle_state\u2019s execution\"\"\" return socless_bootstrap(event, lambda_context, handle_state, include_event=False) The socless_bootstrap function takes the below parameters: Parameter Description Required? Default event Payload containing information the Integration needs to execute. Passed in either by an executing playbook or by a developer during testing. Yes N/A handle_state A function that implements the core logic of the Integration. Must return a dictionary Yes N/A include_event Boolean to specify if the whole playbook execution context (not lambda_context) should be made available to the handle_state function during its execution. Typically set to True for integrations that need to refer to elements of execution context in string templates. If True param1 of handle_state must be the keyword context No FALSE lambda_context The Lambda context object passed in by AWS whenever it triggers a Lambda function Yes N/A In this tutorial, we'll learn the basics of Integration development by writing one that geolocates an IP address and returns its country, latitude and longitude.","title":"Your First Integration: Geolocate IP"},{"location":"your-first-integration-geolocating-an-ip/#setting-up","text":"To begin, change out of socless directory at your command-line (if you\u2019re still within it) to a higher-level project folder. Next, run the commands below to download the socless-integrations-template which contains the pre-configurations we need for developing our Integration git clone git@github.com:twilio/socless-integrations-template.git socless-tutorial cd socless-tutorial ./setup virtualenv --python=python3.7 venv source venv/bin/activate The commands: clone the socless-integrations-template into a folder named socless-tutorial run a setup script that installs the development dependencies we need (serverless framework and relevant plugins) then deletes the setup script. create and activate a Python 3.7 virtual environment which will be used to package our Integration when we're ready to deploy it. After running the commands, you should be left with a socless-tutorial directory that contains a functions folder. This folder is where the code for our tutorial Integrations will live. Now that we're setup, let's code our Integration","title":"Setting Up"},{"location":"your-first-integration-geolocating-an-ip/#coding-the-geoip-integration","text":"For IP address geolocation, we\u2019ll rely on https://tools.keycdn.com/geo.json which is a free geolocation API that requires no auth keys. This allows us keep things simple. Click the link to get an idea of the data the API returns. The geolocation logic for our integration will: be implemented in a handle_state function that only needs an IP as a parameter. use the python requests library to perform a GET request to https://tools.keycdn.com/geo.json with the url parameter host={ip} return a dictionary containing the country name, city name, latitude and longitude of the IP address. Our Integration will have a lambda_handler function that serves as AWS Lambda's entry point for our integration invokes socless_bootstrap to manage its life-cycle return the results of socless_bootstrap Here\u2019s what the implementation of the integration described above looks like import requests from socless import socless_bootstrap def handle_state(ip): r = requests.get(\"https://tools.keycdn.com/geo.json\", params={\"host\": ip}) geoip_info = r.json()['data']['geo'] desired_results = { \"country\": geoip_info['country_name'], \"latitude\": str(geoip_info['latitude']), \"longitude\": str(geoip_info['longitude']) } return desired_results def lambda_handler(event, context): return socless_bootstrap(event, context, handle_state) In the socless-tutorial/functions directory, create a subdirectory called geoip and save the implementation in a file called lambda_function.py . That\u2019s all the code we need to write for our Integrations logic.","title":"Coding the GeoIP Integration"},{"location":"your-first-integration-geolocating-an-ip/#specify-dependencies","text":"Notice that our integration makes use of the Python requests library which isn\u2019t one of the libraries pre-packaged with AWS Lambda. As such, we\u2019ll need to specify requests as a dependency with our deployment package. To do so, open the pre-existing requirements.txt file in the functions directory, and add requests at the bottom of the file. Your file should end up looking like this: git+https://github.com/twilio-labs/socless_python.git#egg=socless requests The first dependency in the file is the Socless Python library that provides the socless_bootstrap function. Any dependency listed in the functions/requirements.txt file gets deployed will all functions in the functions folder. To learn more about configuring dependencies for functions, visit the Socless & Serverless documentation page Our integration\u2019s implementation is complete and our dependencies have been specified. The last thing we need to do is configure the function for deployment.","title":"Specify Dependencies"},{"location":"your-first-integration-geolocating-an-ip/#configuring-our-integration-for-deployment","text":"Socless Integrations are deployed using the Serverless Framework. To deploy our integration, open the serverless.yml file and configure a function that: is reference-able in our config as GeoIP is named socless_tutorial_geoip has a handler at lambda_function.lambda_handler has the description: \"Integration to geolocate an IP address\" creates its source package from functions/geoip Here's what that configuration looks like: functions: GeoIP: name: socless_tutorial_geoip handler: lambda_function.lambda_handler description: Integration to geolocate an ip package: include: - functions/geoip Next, we need to ensure that the AWS ARN of the function is output from the deployment stack after deployment. Doing so will allow the arn to be referenced by the playbook we will write shortly. To accomplish this, include the below configuration in the serverless.yml file, starting on the same indentation level as the functions key-word in the file resources: Outputs: GeoIP: Description: ARN of GeoIP integration Value: Fn::Sub: ${GeoIPLambdaFunction.Arn} With that, our Integration is fully configured for deployment.","title":"Configuring our integration for Deployment"},{"location":"your-first-integration-geolocating-an-ip/#deploying-the-integration","text":"If your Python 3.7 virtual environment is no longer active, reactivate it by running the command . venv/bin/activate from within your socless-tutorial directory. Now, deploy the integration be executing: npm run dev Once the deployment is complete, you should see the ARN for the Integration's Lambda function displayed. You don't need to note this ARN down as we'll reference it by the GeoIP name whenever we need it.","title":"Deploying the Integration"},{"location":"your-first-integration-geolocating-an-ip/#testing-the-integration","text":"Log into the AWS console, navigate to the Lambda service in your Socless dev region, and open the Lambda function for the integration we just deployed (socless_tutorial_geoip). Click Test , and configure the below test event: { \"_testing\": true, \"State_Config\": { \"Name\": \"Test_State\", \"Parameters\": { \"ip\": \"113.63.125.3\" } } } Observe that the key-value pair in the Parameters object maps exactly to the parameters we specified for the handle_state function of our integration. This test event simulates a small subset of the data that the integration would receive when it's called by an actual playbook execution. Give the test event any name of your choosing then hit create. Once the test event is created, click Test to test the integration. If the test executes successfully, you'll have an Execution result like below which shows the test event and the resulting geolocated IP in a results object. { \"_testing\": true, \"State_Config\": { \"Name\": \"Test_State\", \"Parameters\": { \"ip\": \"113.63.125.3\" } }, \"results\": { \"country\": \"China\", \"latitude\": '29.65', \"longitude\": '91.1' } } Feel free to change the IP address in your test case and play around a little.","title":"Testing the Integration"},{"location":"your-first-integration-geolocating-an-ip/#conclusion","text":"Congratulations! You've written, deployed and tested your first integration! Pat yourself on the back, take a breather, then head to the next page to write your second integration","title":"Conclusion"},{"location":"your-first-playbook/","text":"Introduction Socless Playbooks are simply JSON objects that describe the actions to take and resources to use to automate a response plan. On deployment, the JSON objects are converted to State Machines that can be executed by the AWS Step Functions service. As such, the JSON objects are written according to the AWS States Language specification but with some slight differences The basic, bare-bones structure for any Socless Playbook JSON object is shown below: { \"Playbook\": \"\", \"Comment\": \"\", \"StartAt\": \"\", \"States\": { } } It consists of the following top-level fields: - Playbook: (required) UpperCamelCase name of the playbook. eg. InvestigateLogin - Comment: (optional) Human readable description of the playbook - StartAt: (required) The starting state of the playbook - States: (required) A description of all the states in the playbook and their relationships to each other i.e. transitions. Currently, states should be named using the Upper_Case notation e.g Send_Slack_Message In this tutorial, we'll be implementing the InvestigateLogin playbook we discussed in the overview for this tutorial. Our Playbook will be triggered by the alert below { \"alert_name\": \"Anomalous Login IP Detected\", \"details\": [{\"username\": \"bruce.wayne\", \"ip\": \"113.63.125.3\"}], \"response_plan\": \"InvestigateLogin\" } It will respond by taking the following steps: - Geolocate the ip using our GeoIP integration - Use our SendMessage integration to post a notifiction of the login activity + geo ip information to our #bat-signals channel Let's start the tutorial by setting up our playbooks development environment Setting Up Clone Playbooks Template To begin, clone and set up the socless-playbooks-template into your high-level project directory by running the commands below git clone git@github.com:twilio/socless-playbooks-template.git socless-playbooks cd socless-playbooks ./setup The resulting socless-playbooks directory is a Serverless framework application that will serve as the deployment stack for ALL your Socless Playbooks going forward. Within the socless-playbooks directory, create a folder named playbooks . This folder is where all your Playbooks will be written. Reference Integration ARNs in our Playbook stack To complete the setup for our Playbooks stack, let's create references to the ARNs of the Lambda Integrations we deployed in the last tutorial so we can use those Integrations in the playbook we'll create. Open the serverless.yml file. The custom section currently looks like this custom: statesRole: ${{cf:socless-${{self:provider.stage}}.StatesExecutionRoleArn}} socless: CreateEvents: ${{cf:socless-${{self:provider.stage}}.CreateEvents}} MergeParallelOutput: ${{cf:socless-${{self:provider.stage}}.MergeParallelOutput}} Counter: ${{cf:socless-${{self:provider.stage}}.Counter}} AwaitMessageResponseActivity: ${{cf:socless-${{self:provider.stage}}.AwaitMessageResponseActivity}} SetInvestigationStatus: ${{cf:socless-${{self:provider.stage}}.SetInvestigationStatus}} QueryCustomMapping: ${{cf:socless-${{self:provider.stage}}.QueryCustomMapping}} AddCustomMapping: ${{cf:socless-${{self:provider.stage}}.AddCustomMapping}} CacheResults: ${{cf:socless-${{self:provider.stage}}.CacheResults}} Underneath the socless key are references to the ARNs of the Lambda Integrations that Socless' core infrastructure ships with by default. These references will allow us use the ARNs of these Lambda integrations in our Socless playbooks. Whenever you need to use an integration in a Socless playbook, you'll need to ensure that the ARN of the Lambda Integration is referenced here. The current convention for referencing Lambda ARNs in your playbook stack is to nest the Integration names under their relevant \"product\" stack in the custom section of the serverless.yml file. That is custom: product: Integration: ${{cf:socless-product-${{self:provider.stage}}.Integration}} For our tutorial, we have two integrations (GeoIP & SendMessage) that are currently deployed in our tutorial \"product\" stack. Reference their ARNs in our Playbook stack by adding the below code one-indentation level under our custom field (i.e. on the same level as the socless field): tutorial: GeoIP: ${{cf:socless-tutorial-${{self:provider.stage}}.GeoIP}} SendMessage: ${{cf:socless-tutorial-${{self:provider.stage}}.SendMessage}} We will now be able to reference the GeoIP and SendMessage Integrations in our Playbook using the variables ${{self:custom.tutorial.GeoIP}} and ${{self:custom.tutorial.SendMessage}} respectively. The references rely on The Serverless Frameworks' Variable System . Be sure to review that documentation to understand how it works. Coding The Playbook Laying out Basic Structure Our tutorial playbook will be called InvestigateLogin . In our playbooks directory, create a folder called investigate_login . In the investigate_login folder, create a file named playbook.json . This file is where our playbook's implementation will live. It must be called playbook.json . Open the playbook.json file in your favorite text editor and layout the basic structure of our playbook as shown below: { \"Playbook\": \"InvestigateLogin\", \"Comment\": \"Playbook to investigate a login\", \"StartAt\": \"Geolocate_IP\", \"States\": { } } This defines a playbook called InvestigateLogin that starts at a state called Geolocate_IP . Let's configure that Geolocate_IP state in the States object. Configuring the Geolocate_IP state Our Geolocate_IP state will be a Task state that makes use of our GeoIP integration. Courtesy of AWS Step Functions, Socless playbooks support multiple types of states that all serve different purposes in automating a workflow. Task states are primarily used to execute actions in a playbook. Start the definition for our Geolocate_IP state by updating your playbook.json to match the code shown below { \"Playbook\": \"InvestigateLogin\", \"Comment\": \"Playbook to investigate a login\", \"StartAt\": \"Geolocate_IP\", \"States\": { \"Geolocate_IP\": { } } } The update starts the definition for our Geolocate_IP state. Note that the current convention for naming states in Socless is to use Upper_Case_Underscore_Separated notation. A bare-bones configuration for a Task state requires the below field: Type : The state type. For Task states, this must be set to Task Resource : The URI for the resource the state uses to execute its action. For Lambda Integrations, this is the ARN of the Lambda function for the Integration. Since we'll be using the GeoIP Integration, we'll specify its ARN using the ${{self:custom.tutorial.GeoIP}} variable we configured in our serverless.yml file. Parameters : An object with a key-value mapping of all the parameters an Integration needs to complete its action. As explained in the Parameter References & Template Variables documentation, there are many ways to pass parameters to Integrations depending on where the information lives. The IP address we want to geolocate in our playbook is contained in the event payload sent to our Playbook and can be referenced using the parameter $.artifacts.event.details.ip . Since our GeoIP integration requires an ip , we'll pass it the IP using the configuration {\"ip\": \"$.artifacts.event.details.ip\"} A transition configuration, either Next if we're transitioning to another state, or End if the state being configured is the final state of the playbook. Our GeoIP state will transition to \"Notify_Bat_Signals_Channel\" once it completes its execution, so we'll configure a Next transition The full configuration of our Geolocate_IP state is shown below. { \"Playbook\": \"InvestigateLogin\", \"Comment\": \"Playbook to investigate a login\", \"StartAt\": \"Geolocate_IP\", \"States\": { \"Geolocate_IP\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.tutorial.GeoIP}}\", \"Parameters\": { \"ip\": \"$.artifacts.event.details.ip\", }, \"Next\": \"Notify_Bat_Signals_Channel\" } } } The GeoIP Integration used by this state returns country , latitude and longitude . These values will be accessible by subsequent integrations using either Parameter references in the format $.results.Geolocate_IP.* or Template variables in the format {context.results.Geolocate_IP.*} . Configuring the Notify_Bat_Signals_Channel state Next, let's configure our Notify_Bat_Signals_Channel state. This state will also be a Task state. It'll use our SendMessage integration to send a message to our #bat-signals Slack channel. The message will read \" {username} just logged in from {latitude}, {longitude} \". Finally, our state will serve as the End state for our playbook. Extend your playbook.json with the configuration for our state as shown below { \"Playbook\": \"InvestigateLogin\", \"Comment\": \"Playbook to investigate a login\", \"StartAt\": \"Geolocate_IP\", \"States\": { \"Geolocate_IP\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.tutorial.GeoIP}}\", \"Parameters\": { \"ip\": \"$.artifacts.event.details.ip\" }, \"Next\": \"Notify_Bat_Signals_Channel\" }, \"Notify_Bat_Signals_Channel\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.tutorial.SendMessage}}\", \"Parameters\": { \"target\": \"bat-signals\", \"target_type\": \"channel\", \"message_template\": \"`{context.artifacts.event.details.username}` logged in from `{context.results.Geolocate_IP.country_name}` at coordinates `{context.results.Geolocate_IP.latitude}`, `{context.results.Geolocate_IP.longitude}`\" }, \"End\": true } } } Voila! our InvestigateLogin playbook is completely written and ready to deploy. Configuring our Playbook for Deployment Open your serverless.yml file. Add a playbooks sub-section underneath the custom section and list the folder name of the playbook as shown below playbooks: - investigate_login Our playbook is no configured for deployment. Deploying the Playbook To deploy the playbook to our dev environment, execute the below command: npm run dev Conclusion Head to the AWS Step Functions Console in the AWS Region of your Socless dev environment. You should see the InvestigateLogin Playbook listed there. The easiest way to test our playbook is to send an alert to our Playbook through an Event Endpoint. So let's create your first event endpoint","title":"Your First Playbook"},{"location":"your-first-playbook/#introduction","text":"Socless Playbooks are simply JSON objects that describe the actions to take and resources to use to automate a response plan. On deployment, the JSON objects are converted to State Machines that can be executed by the AWS Step Functions service. As such, the JSON objects are written according to the AWS States Language specification but with some slight differences The basic, bare-bones structure for any Socless Playbook JSON object is shown below: { \"Playbook\": \"\", \"Comment\": \"\", \"StartAt\": \"\", \"States\": { } } It consists of the following top-level fields: - Playbook: (required) UpperCamelCase name of the playbook. eg. InvestigateLogin - Comment: (optional) Human readable description of the playbook - StartAt: (required) The starting state of the playbook - States: (required) A description of all the states in the playbook and their relationships to each other i.e. transitions. Currently, states should be named using the Upper_Case notation e.g Send_Slack_Message In this tutorial, we'll be implementing the InvestigateLogin playbook we discussed in the overview for this tutorial. Our Playbook will be triggered by the alert below { \"alert_name\": \"Anomalous Login IP Detected\", \"details\": [{\"username\": \"bruce.wayne\", \"ip\": \"113.63.125.3\"}], \"response_plan\": \"InvestigateLogin\" } It will respond by taking the following steps: - Geolocate the ip using our GeoIP integration - Use our SendMessage integration to post a notifiction of the login activity + geo ip information to our #bat-signals channel Let's start the tutorial by setting up our playbooks development environment","title":"Introduction"},{"location":"your-first-playbook/#setting-up","text":"","title":"Setting Up"},{"location":"your-first-playbook/#clone-playbooks-template","text":"To begin, clone and set up the socless-playbooks-template into your high-level project directory by running the commands below git clone git@github.com:twilio/socless-playbooks-template.git socless-playbooks cd socless-playbooks ./setup The resulting socless-playbooks directory is a Serverless framework application that will serve as the deployment stack for ALL your Socless Playbooks going forward. Within the socless-playbooks directory, create a folder named playbooks . This folder is where all your Playbooks will be written.","title":"Clone Playbooks Template"},{"location":"your-first-playbook/#reference-integration-arns-in-our-playbook-stack","text":"To complete the setup for our Playbooks stack, let's create references to the ARNs of the Lambda Integrations we deployed in the last tutorial so we can use those Integrations in the playbook we'll create. Open the serverless.yml file. The custom section currently looks like this custom: statesRole: ${{cf:socless-${{self:provider.stage}}.StatesExecutionRoleArn}} socless: CreateEvents: ${{cf:socless-${{self:provider.stage}}.CreateEvents}} MergeParallelOutput: ${{cf:socless-${{self:provider.stage}}.MergeParallelOutput}} Counter: ${{cf:socless-${{self:provider.stage}}.Counter}} AwaitMessageResponseActivity: ${{cf:socless-${{self:provider.stage}}.AwaitMessageResponseActivity}} SetInvestigationStatus: ${{cf:socless-${{self:provider.stage}}.SetInvestigationStatus}} QueryCustomMapping: ${{cf:socless-${{self:provider.stage}}.QueryCustomMapping}} AddCustomMapping: ${{cf:socless-${{self:provider.stage}}.AddCustomMapping}} CacheResults: ${{cf:socless-${{self:provider.stage}}.CacheResults}} Underneath the socless key are references to the ARNs of the Lambda Integrations that Socless' core infrastructure ships with by default. These references will allow us use the ARNs of these Lambda integrations in our Socless playbooks. Whenever you need to use an integration in a Socless playbook, you'll need to ensure that the ARN of the Lambda Integration is referenced here. The current convention for referencing Lambda ARNs in your playbook stack is to nest the Integration names under their relevant \"product\" stack in the custom section of the serverless.yml file. That is custom: product: Integration: ${{cf:socless-product-${{self:provider.stage}}.Integration}} For our tutorial, we have two integrations (GeoIP & SendMessage) that are currently deployed in our tutorial \"product\" stack. Reference their ARNs in our Playbook stack by adding the below code one-indentation level under our custom field (i.e. on the same level as the socless field): tutorial: GeoIP: ${{cf:socless-tutorial-${{self:provider.stage}}.GeoIP}} SendMessage: ${{cf:socless-tutorial-${{self:provider.stage}}.SendMessage}} We will now be able to reference the GeoIP and SendMessage Integrations in our Playbook using the variables ${{self:custom.tutorial.GeoIP}} and ${{self:custom.tutorial.SendMessage}} respectively. The references rely on The Serverless Frameworks' Variable System . Be sure to review that documentation to understand how it works.","title":"Reference Integration ARNs in our Playbook stack"},{"location":"your-first-playbook/#coding-the-playbook","text":"","title":"Coding The Playbook"},{"location":"your-first-playbook/#laying-out-basic-structure","text":"Our tutorial playbook will be called InvestigateLogin . In our playbooks directory, create a folder called investigate_login . In the investigate_login folder, create a file named playbook.json . This file is where our playbook's implementation will live. It must be called playbook.json . Open the playbook.json file in your favorite text editor and layout the basic structure of our playbook as shown below: { \"Playbook\": \"InvestigateLogin\", \"Comment\": \"Playbook to investigate a login\", \"StartAt\": \"Geolocate_IP\", \"States\": { } } This defines a playbook called InvestigateLogin that starts at a state called Geolocate_IP . Let's configure that Geolocate_IP state in the States object.","title":"Laying out Basic Structure"},{"location":"your-first-playbook/#configuring-the-geolocate_ip-state","text":"Our Geolocate_IP state will be a Task state that makes use of our GeoIP integration. Courtesy of AWS Step Functions, Socless playbooks support multiple types of states that all serve different purposes in automating a workflow. Task states are primarily used to execute actions in a playbook. Start the definition for our Geolocate_IP state by updating your playbook.json to match the code shown below { \"Playbook\": \"InvestigateLogin\", \"Comment\": \"Playbook to investigate a login\", \"StartAt\": \"Geolocate_IP\", \"States\": { \"Geolocate_IP\": { } } } The update starts the definition for our Geolocate_IP state. Note that the current convention for naming states in Socless is to use Upper_Case_Underscore_Separated notation. A bare-bones configuration for a Task state requires the below field: Type : The state type. For Task states, this must be set to Task Resource : The URI for the resource the state uses to execute its action. For Lambda Integrations, this is the ARN of the Lambda function for the Integration. Since we'll be using the GeoIP Integration, we'll specify its ARN using the ${{self:custom.tutorial.GeoIP}} variable we configured in our serverless.yml file. Parameters : An object with a key-value mapping of all the parameters an Integration needs to complete its action. As explained in the Parameter References & Template Variables documentation, there are many ways to pass parameters to Integrations depending on where the information lives. The IP address we want to geolocate in our playbook is contained in the event payload sent to our Playbook and can be referenced using the parameter $.artifacts.event.details.ip . Since our GeoIP integration requires an ip , we'll pass it the IP using the configuration {\"ip\": \"$.artifacts.event.details.ip\"} A transition configuration, either Next if we're transitioning to another state, or End if the state being configured is the final state of the playbook. Our GeoIP state will transition to \"Notify_Bat_Signals_Channel\" once it completes its execution, so we'll configure a Next transition The full configuration of our Geolocate_IP state is shown below. { \"Playbook\": \"InvestigateLogin\", \"Comment\": \"Playbook to investigate a login\", \"StartAt\": \"Geolocate_IP\", \"States\": { \"Geolocate_IP\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.tutorial.GeoIP}}\", \"Parameters\": { \"ip\": \"$.artifacts.event.details.ip\", }, \"Next\": \"Notify_Bat_Signals_Channel\" } } } The GeoIP Integration used by this state returns country , latitude and longitude . These values will be accessible by subsequent integrations using either Parameter references in the format $.results.Geolocate_IP.* or Template variables in the format {context.results.Geolocate_IP.*} .","title":"Configuring the Geolocate_IP state"},{"location":"your-first-playbook/#configuring-the-notify_bat_signals_channel-state","text":"Next, let's configure our Notify_Bat_Signals_Channel state. This state will also be a Task state. It'll use our SendMessage integration to send a message to our #bat-signals Slack channel. The message will read \" {username} just logged in from {latitude}, {longitude} \". Finally, our state will serve as the End state for our playbook. Extend your playbook.json with the configuration for our state as shown below { \"Playbook\": \"InvestigateLogin\", \"Comment\": \"Playbook to investigate a login\", \"StartAt\": \"Geolocate_IP\", \"States\": { \"Geolocate_IP\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.tutorial.GeoIP}}\", \"Parameters\": { \"ip\": \"$.artifacts.event.details.ip\" }, \"Next\": \"Notify_Bat_Signals_Channel\" }, \"Notify_Bat_Signals_Channel\": { \"Type\": \"Task\", \"Resource\": \"${{self:custom.tutorial.SendMessage}}\", \"Parameters\": { \"target\": \"bat-signals\", \"target_type\": \"channel\", \"message_template\": \"`{context.artifacts.event.details.username}` logged in from `{context.results.Geolocate_IP.country_name}` at coordinates `{context.results.Geolocate_IP.latitude}`, `{context.results.Geolocate_IP.longitude}`\" }, \"End\": true } } } Voila! our InvestigateLogin playbook is completely written and ready to deploy.","title":"Configuring the Notify_Bat_Signals_Channel state"},{"location":"your-first-playbook/#configuring-our-playbook-for-deployment","text":"Open your serverless.yml file. Add a playbooks sub-section underneath the custom section and list the folder name of the playbook as shown below playbooks: - investigate_login Our playbook is no configured for deployment.","title":"Configuring our Playbook for Deployment"},{"location":"your-first-playbook/#deploying-the-playbook","text":"To deploy the playbook to our dev environment, execute the below command: npm run dev","title":"Deploying the Playbook"},{"location":"your-first-playbook/#conclusion","text":"Head to the AWS Step Functions Console in the AWS Region of your Socless dev environment. You should see the InvestigateLogin Playbook listed there. The easiest way to test our playbook is to send an alert to our Playbook through an Event Endpoint. So let's create your first event endpoint","title":"Conclusion"},{"location":"your-second-integration-sending-a-slack-message/","text":"Your Second Integration: Send Slack Message Our second Integration will send a message using Slack. In this tutorial, we'll learn how to: Setup a Slack Bot for use with Socless Store our bots credentials for use with Socless Integrations Create an Integration that uses the Slack bot to send messages This documentation assumes you already have a Slack instance that's ready to use. Setting up a Slack bot Follow the steps below to setup a Slack bot for our tutorial: In a web browser, log into your Slack instance Navigate to https://api.slack.com/apps and hit Create New App Enter a name for your application. The tutorial will use socless-bot Select your development workspace. It should be the workspace you want your bot to be in Hit Create app On the \"Basic Information\" page for your app, click \"Bots\" Click \"Add Bot User\" Set a display name of your choice. We'll use socless-bot Set a default username for your bot. We'll use socless-bot Set \"Always Show My Bot as Online\" to \"On\" Click \"Add Bot User\" again to save the changes In the left sidebar, select \"Oauth & Permissions\" Click \"Install App to Workspace\". Click \"Authorize\" to add the bot to your Slack Workspace Once authorization is complete, you will be redirected back to the \"Oauth & Permissions\" page which will now display a \"Bot User OAuth Access Token\". Note this token down. Our integration will need this token Log into your Slack instance in the Slack app. Click \"Direct Messages\" in the sidebar and search for your bot. Your bot should show up, ready for action. Create a public channel in your Slack instance called \"bat-signals\". We'll need it for the rest of our tutorial. Invite your Slack bot to the #bat-signals channel so that it can send messages to it Storing our Bots Credential for Use in Socless The current recommendation for storing credentials for use in the Socless Framework is to use the AWS Systems Manager (SSM) Parameter Store service. To store the bot token in SSM Parameter Store: Log into your AWS Account in the your Socless dev region and navigate to AWS Systems Manager In the left sidebar of the Systems Manager page, select Parameters Store (you may need to scroll to see it) On the Parameter Store page, click \"Create Parameter\" Name your parameter /socless/slack/bot_token Add a description for the parameter. We'll go with \"Access token for Socless Slack bot\" Under Type , select SecureString. Under KMS Key ID select alias/socless/lambdaKmsKey Under value, paste the Bot User OAuth Access Token Click \"Create Parameter\" Your bot token should now be encrypted and saved in AWS SSM Parameter Store under the name /socless/slack/bot_token . We'll specify that name in our serverless.yml file when we're configuring our integration for deployment We're now set to write our Slack 'Send Message' Integration Writing our Slack 'Send Message' Integration Coding the integration Create a send_message folder in our socless-tutorial/functions directory, and include a lambda_function.py in that folder. In lambda_function.py , implement an integration that: Fetches the Slack bot token from its environment variables. Has a handle_state function with parameters context , target , target_type , message_template where the logic to send a Slack message is implemented. Determines the appropriate Slack ID to send the message to depending the target_type user or channel Invokes the socless_template_string library function to render the message_template using the playbook context Uses the Slack chat.postMessage api to send the message and returns the resulting response from the Slack API in a dictionary Has a lambda_handler entry function that invokes socless_bootstrap to manage its life-cycle with the include_event parameter set to True so that all data from the playbook execution is made available to the integration (we'll need it data to render our message template) Here's our implementation for the integration import slack, os from socless import socless_bootstrap, socless_template_string SOCLESS_BOT_TOKEN = os.environ.get('SOCLESS_BOT_TOKEN') sc = slack.WebClient(token=SOCLESS_BOT_TOKEN) def find_user(name, page_limit=100, include_locale='false'): \"\"\" Find a user's Slack profile based on their full or display name \"\"\" paginate = True next_cursor = '' while paginate: resp = sc.users_list(cursor=next_cursor, limit=page_limit, include_locale=include_locale) data = resp.data next_cursor = resp.data['response_metadata'].get('next_cursor','') if not next_cursor: paginate = False for user in data['members']: user_names = [user.get('name'), user.get('real_name'), user.get('profile',{}).get('real_name')] if name in user_names: return {\"found\":True, \"user\": user} return {\"found\": False} def handle_state(context, target, target_type, message_template): \"\"\" Send a Slack message to either a user or channel \"\"\" target_id = '' # Determine Slack ID for the target if target_type == 'user': result = find_user(target) if result['found'] == False: raise Exception(f\"User {target} not found in Slack instance\") target_id = result['user']['id'] else: target_id = f\"#{target}\" # Render the message template and send the message message = socless_template_string(message_template, context) resp = sc.chat_postMessage(channel=target_id, text=message, as_user=True) return resp.data def lambda_handler(event,lambda_context): return socless_bootstrap(event,lambda_context,handle_state, include_event=True) Specifying Dependencies Our integration relies on the Python slackclient library which isn't available on AWS Lambda by default. To specify that our dependency be included with our deployment package, create a requirements.txt file in the send_message folder and add slackclient to the first line. Because this requirements.txt exists within the send_message folder, slackclient will only be included in the package for the send_message function. Configuring Our Integration for Deployment Open the serverless.yml file. First, in the function section, include a configuration for our integration that: is referenceable as SendMessage named socless_tutorial_send_message in AWS Lambda Has handler lambda_function.lambda_handler Has the description \"Sends a message via Slack\" Creates its source package from functions/send_message Has environment variable SOCLESS_BOT_TOKEN which references the Slack bot token we saved in SSM as socless/slack/bot_token Here's what that configuration looks like: SendMessage: name: socless_tutorial_send_message handler: lambda_function.lambda_handler description: Send a message using Slack package: include: - functions/send_message environment: SOCLESS_BOT_TOKEN: ${{ssm:/socless/slack/bot_token~true}} Ensure the configuration starts at one-indentiation level under the functions section. This configuration will deploy a Lambda function and Cloudwatch Log Group that are referenceable as SendMessagelambdaFunction and SendMessageLogGroup respectively. Next, in the resources Output section, expose the ARN of the Lambda function using the configuration below so that it can be referenced by playbooks SendMessage: Description: ARN of SendMessage Integration Value: Fn::Sub: ${SendMessageLambdaFunction.Arn} With that, our integration is fully configured and ready for deployment Deploying the integration Activate your Python 3 virtual environment (if it is no longer active), and run the below command within the socless-tutorial directory npm run dev Once the deployment is complete, you should see the ARN for the integration's Lambda function displayed. You don't need to note this ARN down as we'll reference it by the SendMessage name whenever we need it Testing the Integration Log into the AWS Console, navigate to the Lambda service in your Socless dev region and open the socless_tutorial_send_message integration which we just deployed. Configure the below test event which sends a \"hello world\" message to the bat-signals channel which we created and added our bot to earlier in the tutorial { \"_testing\": true, \"State_Config\": { \"Name\": \"Test_State\", \"Parameters\": { \"target\": \"bat-signals\", \"target_type\": \"channel\", \"message_template\": \"Hello, world!\" } } } Save and execute the test case, You should get a \"Hello, world!\" message from the bot in the bat-signals channel. Now, let's configure a second test case that's much more representative of how we'd use our integration in a full-fledged playbook. It includes an artifacts object which simulates information about the alert that triggered the playbook that calls our integration. { \"_testing\": true, \"artifacts\": { \"event\": { \"details\": { \"distress_channel\": \"bat-signals\", \"distressed_user\": \"Commissioner Gordon\" } } }, \"State_Config\": { \"Name\": \"Test_State\", \"Parameters\": { \"target\": \"$.artifacts.event.details.distress_channel\", \"target_type\": \"channel\", \"message_template\": \"The Bat Signal was turned on by {context.artifacts.event.details.distressed_user}\" } } } Save the test case and execute the function. You should receive a message in the bat-signals channel that reads \"The Bat Signal was turned on by Commissioner Gordon\". However, as you can see from our Parameters config, neither the \"bat-signals\" channel nor \"Commissioner Gordon\" were explicitly passed to the target or message_template parameters. Instead, those values were passed using a Parameter reference (with format $.* ) and a template variable (format {context.*} ) respectively that referenced the parts of our artifacts object that contained the information we needed. You can learn all about parameter references and template variables in the Parameter References & Template Variables documentation, or you can keep following the tutorial to learn as you go. Conclusion We've created our second integration! :champagne: In doing so we've: Learned how to store credentials and AWS SSM Parameter Store for use with Socless Integrations How to pass those parameters to our integration via an environment variable configuration Gotten a very brief intro to Parameter References & Template Variables With both integrations created, we're ready to write our first playbook. Head to the next page to begin","title":"Your Second Integration: Sending a Slack Message"},{"location":"your-second-integration-sending-a-slack-message/#your-second-integration-send-slack-message","text":"Our second Integration will send a message using Slack. In this tutorial, we'll learn how to: Setup a Slack Bot for use with Socless Store our bots credentials for use with Socless Integrations Create an Integration that uses the Slack bot to send messages This documentation assumes you already have a Slack instance that's ready to use.","title":"Your Second Integration: Send Slack Message"},{"location":"your-second-integration-sending-a-slack-message/#setting-up-a-slack-bot","text":"Follow the steps below to setup a Slack bot for our tutorial: In a web browser, log into your Slack instance Navigate to https://api.slack.com/apps and hit Create New App Enter a name for your application. The tutorial will use socless-bot Select your development workspace. It should be the workspace you want your bot to be in Hit Create app On the \"Basic Information\" page for your app, click \"Bots\" Click \"Add Bot User\" Set a display name of your choice. We'll use socless-bot Set a default username for your bot. We'll use socless-bot Set \"Always Show My Bot as Online\" to \"On\" Click \"Add Bot User\" again to save the changes In the left sidebar, select \"Oauth & Permissions\" Click \"Install App to Workspace\". Click \"Authorize\" to add the bot to your Slack Workspace Once authorization is complete, you will be redirected back to the \"Oauth & Permissions\" page which will now display a \"Bot User OAuth Access Token\". Note this token down. Our integration will need this token Log into your Slack instance in the Slack app. Click \"Direct Messages\" in the sidebar and search for your bot. Your bot should show up, ready for action. Create a public channel in your Slack instance called \"bat-signals\". We'll need it for the rest of our tutorial. Invite your Slack bot to the #bat-signals channel so that it can send messages to it","title":"Setting up a Slack bot"},{"location":"your-second-integration-sending-a-slack-message/#storing-our-bots-credential-for-use-in-socless","text":"The current recommendation for storing credentials for use in the Socless Framework is to use the AWS Systems Manager (SSM) Parameter Store service. To store the bot token in SSM Parameter Store: Log into your AWS Account in the your Socless dev region and navigate to AWS Systems Manager In the left sidebar of the Systems Manager page, select Parameters Store (you may need to scroll to see it) On the Parameter Store page, click \"Create Parameter\" Name your parameter /socless/slack/bot_token Add a description for the parameter. We'll go with \"Access token for Socless Slack bot\" Under Type , select SecureString. Under KMS Key ID select alias/socless/lambdaKmsKey Under value, paste the Bot User OAuth Access Token Click \"Create Parameter\" Your bot token should now be encrypted and saved in AWS SSM Parameter Store under the name /socless/slack/bot_token . We'll specify that name in our serverless.yml file when we're configuring our integration for deployment We're now set to write our Slack 'Send Message' Integration","title":"Storing our Bots Credential for Use in Socless"},{"location":"your-second-integration-sending-a-slack-message/#writing-our-slack-send-message-integration","text":"","title":"Writing our Slack 'Send Message' Integration"},{"location":"your-second-integration-sending-a-slack-message/#coding-the-integration","text":"Create a send_message folder in our socless-tutorial/functions directory, and include a lambda_function.py in that folder. In lambda_function.py , implement an integration that: Fetches the Slack bot token from its environment variables. Has a handle_state function with parameters context , target , target_type , message_template where the logic to send a Slack message is implemented. Determines the appropriate Slack ID to send the message to depending the target_type user or channel Invokes the socless_template_string library function to render the message_template using the playbook context Uses the Slack chat.postMessage api to send the message and returns the resulting response from the Slack API in a dictionary Has a lambda_handler entry function that invokes socless_bootstrap to manage its life-cycle with the include_event parameter set to True so that all data from the playbook execution is made available to the integration (we'll need it data to render our message template) Here's our implementation for the integration import slack, os from socless import socless_bootstrap, socless_template_string SOCLESS_BOT_TOKEN = os.environ.get('SOCLESS_BOT_TOKEN') sc = slack.WebClient(token=SOCLESS_BOT_TOKEN) def find_user(name, page_limit=100, include_locale='false'): \"\"\" Find a user's Slack profile based on their full or display name \"\"\" paginate = True next_cursor = '' while paginate: resp = sc.users_list(cursor=next_cursor, limit=page_limit, include_locale=include_locale) data = resp.data next_cursor = resp.data['response_metadata'].get('next_cursor','') if not next_cursor: paginate = False for user in data['members']: user_names = [user.get('name'), user.get('real_name'), user.get('profile',{}).get('real_name')] if name in user_names: return {\"found\":True, \"user\": user} return {\"found\": False} def handle_state(context, target, target_type, message_template): \"\"\" Send a Slack message to either a user or channel \"\"\" target_id = '' # Determine Slack ID for the target if target_type == 'user': result = find_user(target) if result['found'] == False: raise Exception(f\"User {target} not found in Slack instance\") target_id = result['user']['id'] else: target_id = f\"#{target}\" # Render the message template and send the message message = socless_template_string(message_template, context) resp = sc.chat_postMessage(channel=target_id, text=message, as_user=True) return resp.data def lambda_handler(event,lambda_context): return socless_bootstrap(event,lambda_context,handle_state, include_event=True)","title":"Coding the integration"},{"location":"your-second-integration-sending-a-slack-message/#specifying-dependencies","text":"Our integration relies on the Python slackclient library which isn't available on AWS Lambda by default. To specify that our dependency be included with our deployment package, create a requirements.txt file in the send_message folder and add slackclient to the first line. Because this requirements.txt exists within the send_message folder, slackclient will only be included in the package for the send_message function.","title":"Specifying Dependencies"},{"location":"your-second-integration-sending-a-slack-message/#configuring-our-integration-for-deployment","text":"Open the serverless.yml file. First, in the function section, include a configuration for our integration that: is referenceable as SendMessage named socless_tutorial_send_message in AWS Lambda Has handler lambda_function.lambda_handler Has the description \"Sends a message via Slack\" Creates its source package from functions/send_message Has environment variable SOCLESS_BOT_TOKEN which references the Slack bot token we saved in SSM as socless/slack/bot_token Here's what that configuration looks like: SendMessage: name: socless_tutorial_send_message handler: lambda_function.lambda_handler description: Send a message using Slack package: include: - functions/send_message environment: SOCLESS_BOT_TOKEN: ${{ssm:/socless/slack/bot_token~true}} Ensure the configuration starts at one-indentiation level under the functions section. This configuration will deploy a Lambda function and Cloudwatch Log Group that are referenceable as SendMessagelambdaFunction and SendMessageLogGroup respectively. Next, in the resources Output section, expose the ARN of the Lambda function using the configuration below so that it can be referenced by playbooks SendMessage: Description: ARN of SendMessage Integration Value: Fn::Sub: ${SendMessageLambdaFunction.Arn} With that, our integration is fully configured and ready for deployment","title":"Configuring Our Integration for Deployment"},{"location":"your-second-integration-sending-a-slack-message/#deploying-the-integration","text":"Activate your Python 3 virtual environment (if it is no longer active), and run the below command within the socless-tutorial directory npm run dev Once the deployment is complete, you should see the ARN for the integration's Lambda function displayed. You don't need to note this ARN down as we'll reference it by the SendMessage name whenever we need it","title":"Deploying the integration"},{"location":"your-second-integration-sending-a-slack-message/#testing-the-integration","text":"Log into the AWS Console, navigate to the Lambda service in your Socless dev region and open the socless_tutorial_send_message integration which we just deployed. Configure the below test event which sends a \"hello world\" message to the bat-signals channel which we created and added our bot to earlier in the tutorial { \"_testing\": true, \"State_Config\": { \"Name\": \"Test_State\", \"Parameters\": { \"target\": \"bat-signals\", \"target_type\": \"channel\", \"message_template\": \"Hello, world!\" } } } Save and execute the test case, You should get a \"Hello, world!\" message from the bot in the bat-signals channel. Now, let's configure a second test case that's much more representative of how we'd use our integration in a full-fledged playbook. It includes an artifacts object which simulates information about the alert that triggered the playbook that calls our integration. { \"_testing\": true, \"artifacts\": { \"event\": { \"details\": { \"distress_channel\": \"bat-signals\", \"distressed_user\": \"Commissioner Gordon\" } } }, \"State_Config\": { \"Name\": \"Test_State\", \"Parameters\": { \"target\": \"$.artifacts.event.details.distress_channel\", \"target_type\": \"channel\", \"message_template\": \"The Bat Signal was turned on by {context.artifacts.event.details.distressed_user}\" } } } Save the test case and execute the function. You should receive a message in the bat-signals channel that reads \"The Bat Signal was turned on by Commissioner Gordon\". However, as you can see from our Parameters config, neither the \"bat-signals\" channel nor \"Commissioner Gordon\" were explicitly passed to the target or message_template parameters. Instead, those values were passed using a Parameter reference (with format $.* ) and a template variable (format {context.*} ) respectively that referenced the parts of our artifacts object that contained the information we needed. You can learn all about parameter references and template variables in the Parameter References & Template Variables documentation, or you can keep following the tutorial to learn as you go.","title":"Testing the Integration"},{"location":"your-second-integration-sending-a-slack-message/#conclusion","text":"We've created our second integration! :champagne: In doing so we've: Learned how to store credentials and AWS SSM Parameter Store for use with Socless Integrations How to pass those parameters to our integration via an environment variable configuration Gotten a very brief intro to Parameter References & Template Variables With both integrations created, we're ready to write our first playbook. Head to the next page to begin","title":"Conclusion"}]}